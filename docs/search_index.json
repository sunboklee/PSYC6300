[
["index.html", "R, Rstudio, and ggplot2 Chapter 1 R 1.1 Why R? 1.2 Installing R 1.3 Installing RStudio 1.4 Cheat Sheets for R 1.5 Rmarkdown files 1.6 R topics covered in this course", " R, Rstudio, and ggplot2 Sunbok Lee 2019-09-11 Chapter 1 R 1.1 Why R? R is a free open source software. R is a language designed especially for statistical analysis. Many statistical methods are first implemented in R. R provides many tools for publication-quality data visualization (e.g., ggplot2). R provides many tools for data processing (or data wrangling) (e.g., dplyr, tidyr). Data come from diverse sources these days (e.g., microarray, EEG, fMRI, eyetrackers, facebook, twitter, many sensors, … ). e.g., JSON is a popular file format for data exchange: https://en.wikipedia.org/wiki/JSON e.g., Biometric research: IMotions 1.2 Installing R You can download and install a base distribution and packages (base R) from the official R webiste: https://www.r-project.org. About 14,000 packages extend the base R. R packages are collections of functions and data sets developed by the R community. They increase the power of R by improving existing base R functionalities. A list of R packages are available here:https://cran.r-project.org/web/packages/available_packages_by_name.html 1.3 Installing RStudio RStudio is an integrated development environment (IDE) for R. You can download and install the RStudio from the RStudio website: https://www.rstudio.com. A short tour to the RStudio IDE: https://www.rstudio.com/products/rstudio/. 1.4 Cheat Sheets for R RStudio provides cheat sheets for R: https://www.rstudio.com/resources/cheatsheets/. 1.5 Rmarkdown files Rmarkdown files for this materials can be downloaded here: https://github.com/sunboklee/PSYC6300 1.6 R topics covered in this course Base R tidyverse The tidyverse package was developed for more efficient data science in R. In the tidyverse package, the dplyr, tidyr, ggplot2, and purrr packages provide many useful functions for efficient data transformation, data tidying, data visualization, and iteration, respectively. Useful free R books: https://bookdown.org. R for Data Science (Wickham and Grolemund 2017) is a useful resource for the tidyverse package. References "],
["introduction-to-ggplot2.html", "Chapter 2 Introduction to ggplot2 2.1 What is ggplot2? 2.2 Installing and laoding ggplot2 2.3 Graphical components of ggplot2 2.4 Saving a ggplot 2.5 More resources", " Chapter 2 Introduction to ggplot2 2.1 What is ggplot2? The ggplot2 package (Wickham 2016) was developed to create a graphic by combining few graphical components (e.g., data, coordinate systems, geometric objects, aesthetics, facets, themes) based on the grammar of graphics. “Wilkinson (2005) created the grammar of graphics to describe the deep features that underlie all statistical graphics. The grammar of graphics is an answer to a question: what is a statistical graphic? The layered grammar of graphics (Wickham, 2009) builds on Wilkinson’s grammar, focussing on the primacy of layers and adapting it for embedding within R. In brief, the grammar tells us that a statistical graphic is a mapping from data to aesthetic attributes (colour, shape, size) of geometric objects (points, lines, bars). The plot may also contain statistical transformations of the data and is drawn on a specific coordinate system. Faceting can be used to generate the same plot for different subsets of the dataset. It is the combination of these independent components that make up a graphic.” — Wickham (2016) 2.2 Installing and laoding ggplot2 Install the ggplot2 package (or any package) using install.packages() function using the Packages pane install.packages(&quot;ggplot2&quot;) Load the tidyverse package onto memory # We need to load a package whenever we use it library(ggplot2) 2.3 Graphical components of ggplot2 Data Geometric objects (geom for short) Aesthetic mappings Statistical transformations (stats for short) Scales A coordinate system (coord for short) A faceting 2.3.1 Data “The data are what you want to visualise.” (Wickham 2016) You may need data transformation (e.g., selecting variables and rows, creating new variables, summarizing variables) from your raw data. # diamonds is a built-in data in ggplot2 # ?diamonds display the help document for data # tibble is a datastructure in tidyverse diamonds ## # A tibble: 53,940 x 10 ## carat cut color clarity depth table price x y z ## &lt;dbl&gt; &lt;ord&gt; &lt;ord&gt; &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0.23 Ideal E SI2 61.5 55 326 3.95 3.98 2.43 ## 2 0.21 Premium E SI1 59.8 61 326 3.89 3.84 2.31 ## 3 0.23 Good E VS1 56.9 65 327 4.05 4.07 2.31 ## 4 0.290 Premium I VS2 62.4 58 334 4.2 4.23 2.63 ## 5 0.31 Good J SI2 63.3 58 335 4.34 4.35 2.75 ## 6 0.24 Very Good J VVS2 62.8 57 336 3.94 3.96 2.48 ## 7 0.24 Very Good I VVS1 62.3 57 336 3.95 3.98 2.47 ## 8 0.26 Very Good H SI1 61.9 55 337 4.07 4.11 2.53 ## 9 0.22 Fair E VS2 65.1 61 337 3.87 3.78 2.49 ## 10 0.23 Very Good H VS1 59.4 61 338 4 4.05 2.39 ## # … with 53,930 more rows 2.3.2 Geometric objects (geoms) “Geometric objects, geoms for short, represent what you actually see on the plot: points, lines, polygons, etc.” (Wickham 2016) In ggplot2, we add a new layer representing a geometric object to a plot using a geom_*() or stat_*() function. # ggplot() initializes a ggplot object. # In ggplot(), you need to specify 1) a dataset, and 2) aesthetic mapping. # No geometric object yet. ggplot(data = diamonds, aes(x = carat, y = price)) # geom_points() adds a new layer to a plot by drawing points to produce a scatter plot ggplot(data = diamonds, aes(x = carat, y = price)) + geom_point() # geom_smooth() adds an additional layer to the plot by drawing a smoothed line to capture the trend in the scatterplot ggplot(data = diamonds, aes(x = carat, y = price)) + geom_point() + geom_smooth() ## `geom_smooth()` using method = &#39;gam&#39; and formula &#39;y ~ s(x, bs = &quot;cs&quot;)&#39; Exercise Create code chunks (gray area in a rmd file) using a short cut key (Mac: Command + Option + I; Windows: Ctrl + Alt + I). Typing mtcars in your code chunks will display the content of the mtcars dataset. How can we display the help document for the mtcars data? Type head(mtcars). What did head() do? Check the help document of head() (mtcar is a dataframe in base R, whereas the diamonds is a tibble in tidyverse). Using the mtcars data, plot the scatter plot between mpg (miles per gallon: y axis) and disp (displacement: x axis) with a smoothed line. 2.3.3 Aesthetic mappings “A set of aesthetic mappings describe how variables in the data are mapped to aesthetic properties of the layer” (Wickham 2016) “To describe the way that variables in the data are mapped to things that we can perceive on the plot (the &quot;aesthetics&quot;), we use the aes function. The aes function takes a list of aesthetic-variable pairs like these: aes(x = weight, y = height, colour = age). Here we are mapping x-position to weight, y-position to height and colour to age. The first two arguments can be left without names, in which case they correspond to the x and y variables.” (Wickham 2016) Aesthetic properties include position (e.g., x and y coordinates) color (outside color) fill (inside color) shape (of points; e.g., circle, triangle) linetype (e.g., solid line, dotted line) size alpha (transparency) # `color = color` maps the variable `color` in the dataset to the `color` aesthetics of points to encode further information in the graphic. ggplot(data = diamonds, aes(x = carat, y = price, color = color)) + geom_point() # `shape = cut` maps the `shape` aesthetics of points to the variable `cut` in the dataset to encode further information in the graphic. # Note that the graphic is not so informative because points are overplotted. Sometimes, facetting may handle overplotting. ggplot(data = diamonds, aes(x = carat, y = price, shape = cut)) + geom_point() ## Warning: Using shapes for an ordinal variable is not advised # We can set aesthetic properties to a constant outside aes() function. ggplot(data = diamonds, aes(x = carat, y = price)) + geom_point(color = &quot;blue&quot;) Exercise mpg is similar to mtcars but is a built-in tibble in ggplot2. 1) Plot hwy (mile per gallon: y axis) against displ (engine displancement: x axis), 2) Given the plot from 1), map the class variable to color, shape, alpha, and size aesthetics. Explain what happens. ggplot(data = mpg, mapping = aes(x = displ, y = hwy, color=drv)) + geom_point() + geom_smooth(method=&quot;lm&quot;) This is what happens when mapping x, y, and color aesthetics to hyw, displ, and cyl variables: R creates a new dataset that contains all the data to be displayed on the plot. x y color 1.8 29 4 1.8 29 4 2.0 31 4 2.0 30 4 2.8 26 6 2.8 26 6 3.1 27 6 1.8 26 4 1.8 25 4 2.0 28 4 2.3.4 Scales “The scales map values in the data space to values in an aesthetic space, whether it be colour, or size, or shape. Scales draw a legend or axes, which provide an inverse mapping to make it possible to read the original data values from the graph.” (Wickham 2016) In the previous table, computers don’t know how to display colors based on 4, 6, … Computers need a hexadecimal code for colors such as FF6C91. The mapping from the data to the final values that computers can use to display aesthetics is called a scale. In this sense, a scale controls aesthetic mapping from data to aesthetics. To control the mapping, use a custom scale using scale_*() functions. x y color 1.8 29 #FF6C91 1.8 29 #FF6C91 2.0 31 #FF6C91 2.0 30 #FF6C91 2.8 26 #00C1A9 2.8 26 #00C1A9 3.1 27 #00C1A9 1.8 26 #FF6C91 1.8 25 #FF6C91 2.0 28 #FF6C91 e.g., scale_x_continuous() and scale_y_continuous() allow us to change the default scales for continuous x and y aesthetics: https://ggplot2.tidyverse.org/reference/scale_continuous.html. p1 &lt;- ggplot(mpg, aes(displ, hwy)) + geom_point() p1 # change the axis labels p1 + scale_x_continuous(&quot;Engine displacement (L)&quot;) + scale_y_continuous(&quot;Highway MPG&quot;) # also use the short-cut labs() p1 + labs(x = &quot;Engine displacement (L)&quot;, y = &quot;Highway MPG&quot;) # modify the axis limits p1 + scale_x_continuous(limits = c(2, 6)) ## Warning: Removed 27 rows containing missing values (geom_point). # use the short hand functions `xlim()` and `ylim()` p1 + xlim(2, 6) ## Warning: Removed 27 rows containing missing values (geom_point). # choose where the ticks appear p1 + scale_x_continuous(breaks = c(2, 4, 6)) # choose your own labels p1 + scale_x_continuous(breaks = c(2, 4, 6), label = c(&quot;two&quot;, &quot;four&quot;, &quot;six&quot;)) ggplot(data = mpg, mapping = aes(x = displ, y = hwy, color=drv)) + geom_point() + geom_smooth(method=&quot;lm&quot;) + labs(title =&quot;MPG vs Engine size&quot;, x = &quot;Engine size&quot;, y = &quot;MPG&quot;) # Create your own discrete scale ggplot(data = mpg, mapping = aes(x = displ, y = hwy, color=drv)) + geom_point() + geom_smooth(method=&quot;lm&quot;) + labs(title =&quot;MPG vs Engine size&quot;, x = &quot;Engine size&quot;, y = &quot;MPG&quot;) + scale_colour_manual(name = &quot;Drive&quot;, values = c(&quot;lightpink&quot;, &quot;darkseagreen&quot;, &quot;lightblue&quot;)) ggplot(data = mpg, mapping = aes(x = displ, y = hwy, color=cty)) + geom_point() ggplot(data = mpg, mapping = aes(x = displ, y = hwy, color=cty)) + geom_point() + scale_colour_gradient(name = &quot;City MPG&quot;, low = &quot;red&quot;, high = &quot;blue&quot;) For more details about scales, see https://ggplot2.tidyverse.org/reference/. Colors in R: http://www.sthda.com/english/wiki/colors-in-r 2.3.5 Statistical transformations (stats for short) # historam shows the distribution of a single variable. # where does the `count` in the plot come from? ggplot(data = diamonds, aes(x = carat)) + geom_histogram() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. “Statistical transformations, stats for short, summarise data in many useful ways. For example, binning and counting observations to create a histogram, or summarising a 2d relationship with a linear model. Stats are optional, but very useful.” (Wickham 2016) How geom_histogram() works? &quot;A stat takes a dataset as input and returns a dataset as output, and so a stat can add new variables to the original dataset. It is possible to map aesthetics to these new variables. For example, stat_bin, the statistic used to make histograms, produces the following variables: count, the number of observations in each bin density, the density of observations in each bin (percentage of total / bar width) x, the centre of the bin&quot; (Wickham 2016) “These generated variables can be used instead of the variables present in the original dataset. For example, the default histogram geom assigns the height of the bars to the number of observations (count), but if you’d prefer a more traditional histogram, you can use the density (density). The following example shows a density histogram of carat from the diamonds dataset.” (Wickham 2016) # The names of generated variables must be surrounded with .. ggplot(diamonds, aes(carat)) + geom_histogram(aes(y = ..density..), binwidth = 0.1) Every geom has a default stats. # An alternative way to build a layer ggplot(diamonds, aes(carat)) + stat_bin() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Position adjustments Position adjustments determine how to arrange geoms that would otherwise occupy the same space. # The discrete analogue of histogram is the bar plot s &lt;- ggplot(mpg, aes(fl, fill = drv)) s + geom_bar() # Stack elements on top of one another s + geom_bar(position = &quot;stack&quot;) # Arrange elements side by side s + geom_bar(position = &quot;dodge&quot;) # Stack elements on top of one another,normalize height s + geom_bar(position = &quot;fill&quot;) 2.3.6 A faceting “A faceting specification describes how to break up the data into subsets and how to display those subsets as small multiples. This is also known as conditioning or latticing/trellising.” (Wickham 2016) “There are two types of faceting provided by ggplot2: facet_grid and facet_wrap. Facet grid produces a 2d grid of panels defined by variables which form the rows and columns, while facet wrap produces a 1d ribbon of panels that is wrapped into 2d” (Wickham 2016) # facet into rows ggplot(data = diamonds, aes(x = carat)) + geom_histogram() + facet_grid(color ~ .) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. # facet into columns ggplot(data = diamonds, aes(x = carat)) + geom_histogram() + facet_grid(. ~ color) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Exercise Using mpg data, plot hwy (y) vs cty (x). facet into rows using cyl. facet into columns using cyl. facet into rows using cyl and columns using year 2.3.7 Grouping “In many situations, you want to separate your data into groups, but render them in the same way. When looking at the data in aggregate you want to be able to distinguish individual subjects, but not identify them. This is common in longitudinal studies with many subjects, where the plots are often descriptively called spaghetti plots.” (Wickham 2016) Oxboys is a dataset in the nlme package. Oxboys includes the height of a selection of boys from Oxford, England versus a standardized age. library(nlme) # age = a numeric vector giving the standardized age head(Oxboys) ## Grouped Data: height ~ age | Subject ## Subject age height Occasion ## 1 1 -1.0000 140.5 1 ## 2 1 -0.7479 143.4 2 ## 3 1 -0.4630 144.8 3 ## 4 1 -0.1643 147.1 4 ## 5 1 -0.0027 147.7 5 ## 6 1 0.2466 150.2 6 ggplot(Oxboys, aes(age, height)) + geom_line() ggplot(Oxboys, aes(age, height, group = Subject)) + geom_line() # In many cases, this is not what we want ggplot(Oxboys, aes(age, height, group = Subject)) + geom_line() + geom_smooth() ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; # group = 1 override the default grouping ggplot(Oxboys, aes(age, height, group = Subject)) + geom_line() + geom_smooth(aes(group = 1)) ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; # facet is also useful for visualizing longitudinal data ggplot(Oxboys, aes(age, height)) + geom_line() + facet_wrap(~Subject) 2.3.8 Themes “Themes are a powerful way to customize the non-data components of your plots: i.e. titles, labels, fonts, background, gridlines, and legends.” More details are available at https://ggplot2.tidyverse.org/reference/theme.html ggplot(mpg, aes(x = hwy, y = cty)) + geom_point() ggplot(mpg, aes(x = hwy, y = cty)) + geom_point() + theme(panel.background = element_rect(fill = &quot;white&quot;, colour = &quot;grey50&quot;)) ggplot(mpg, aes(x = hwy, y = cty)) + geom_point() + theme_classic() 2.4 Saving a ggplot ggsave() is a convenient function for saving a plot. It defaults to saving the last plot that you displayed. ggsave(&quot;mtcars.pdf&quot;) ## Saving 7 x 5 in image 2.5 More resources ggplot2 Reference: https://ggplot2.tidyverse.org/reference/index.html Many R galleries (e.g., https://www.r-graph-gallery.com) Google References "],
["descriptive-statistics.html", "Chapter 3 Descriptive Statistics 3.1 R functions for descriptive statistics 3.2 qplot() 3.3 Scatterplots 3.4 Histogram 3.5 Density plots 3.6 Barplots 3.7 Boxplots 3.8 Faceting 3.9 The corrplot Package", " Chapter 3 Descriptive Statistics 3.1 R functions for descriptive statistics # compute mean # we use $ to access `price` variable in the `diamonds` dataset mean(diamonds$price) ## [1] 3932.8 # compute median median(diamonds$price) ## [1] 2401 # compute variance var(diamonds$price) ## [1] 15915629 # compute standard deviation sd(diamonds$price) ## [1] 3989.44 # summary of a data frame summary(diamonds) ## carat cut color clarity ## Min. :0.2000 Fair : 1610 D: 6775 SI1 :13065 ## 1st Qu.:0.4000 Good : 4906 E: 9797 VS2 :12258 ## Median :0.7000 Very Good:12082 F: 9542 SI2 : 9194 ## Mean :0.7979 Premium :13791 G:11292 VS1 : 8171 ## 3rd Qu.:1.0400 Ideal :21551 H: 8304 VVS2 : 5066 ## Max. :5.0100 I: 5422 VVS1 : 3655 ## J: 2808 (Other): 2531 ## depth table price x ## Min. :43.00 Min. :43.00 Min. : 326 Min. : 0.000 ## 1st Qu.:61.00 1st Qu.:56.00 1st Qu.: 950 1st Qu.: 4.710 ## Median :61.80 Median :57.00 Median : 2401 Median : 5.700 ## Mean :61.75 Mean :57.46 Mean : 3933 Mean : 5.731 ## 3rd Qu.:62.50 3rd Qu.:59.00 3rd Qu.: 5324 3rd Qu.: 6.540 ## Max. :79.00 Max. :95.00 Max. :18823 Max. :10.740 ## ## y z ## Min. : 0.000 Min. : 0.000 ## 1st Qu.: 4.720 1st Qu.: 2.910 ## Median : 5.710 Median : 3.530 ## Mean : 5.735 Mean : 3.539 ## 3rd Qu.: 6.540 3rd Qu.: 4.040 ## Max. :58.900 Max. :31.800 ## 3.2 qplot() qplot(), short for quick plot is a function in the ggplot2 package. qplot makes it easy to produce complex plots, often requiring several lines of code using other plotting systems, in one line. 3.3 Scatterplots ggplot(data = mpg, aes(x = displ, y = hwy)) + geom_point() qplot(displ, hwy, data = mpg) ggplot(data = mpg, aes(x = displ, y = hwy, color = class)) + geom_point() qplot(displ, hwy, data = mpg, color = class) ggplot(data = mpg, aes(x = displ, y = hwy, color = class, shape = drv)) + geom_point() qplot(displ, hwy, data = mpg, color = class, shape = drv) ggplot(data = mpg, aes(x = displ, y = hwy)) + geom_point() + geom_smooth(method = &quot;lm&quot;) qplot(displ, hwy, data = mpg, geom = c(&quot;point&quot;, &quot;smooth&quot;)) ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; 3.4 Histogram ggplot(data = diamonds, aes(x = carat)) + geom_histogram() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. qplot(carat, data = diamonds, geom = &quot;histogram&quot;) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ggplot(data = diamonds, aes(x = carat)) + geom_histogram(binwidth = 0.05) + xlim(c(0,3)) ## Warning: Removed 32 rows containing non-finite values (stat_bin). ## Warning: Removed 2 rows containing missing values (geom_bar). qplot(carat, data = diamonds, geom = &quot;histogram&quot;, binwidth = 0.05, xlim = c(0,3)) ## Warning: Removed 32 rows containing non-finite values (stat_bin). ## Warning: Removed 2 rows containing missing values (geom_bar). ggplot(data = mpg, aes(x = hwy, fill = drv)) + geom_histogram() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. qplot(hwy, data = mpg, geom = &quot;histogram&quot;, fill = drv) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. 3.5 Density plots ggplot(data = diamonds, aes(x = carat, color = color)) + geom_density() qplot(carat, data = diamonds, geom = &quot;density&quot;, color = color) 3.6 Barplots ggplot(data = diamonds, aes(x = clarity)) + geom_bar() qplot(clarity, data = diamonds, geom = &quot;bar&quot;) ggplot(data = diamonds, aes(x = clarity, fill = cut)) + geom_bar() qplot(clarity, data = diamonds, geom = &quot;bar&quot;, fill = cut) 3.7 Boxplots ggplot(data = diamonds, aes(y = price)) + geom_boxplot() qplot(y = price, data = diamonds, geom = &quot;boxplot&quot;) ggplot(data = diamonds, aes(x = cut, y = price)) + geom_boxplot() 3.8 Faceting ggplot(data = diamonds, aes(x = carat, y = price)) + geom_point() + facet_grid(cut ~ color) qplot(carat, price, data = diamonds, facets = cut ~ color) 3.9 The corrplot Package https://cran.r-project.org/web/packages/corrplot/vignettes/corrplot-intro.html “The corrplot package is a graphical display of a correlation matrix, confidence interval. It also contains some algorithms to do matrix reordering. In addition, corrplot is good at details, including choosing color, text labels, color labels, layout, etc.” library(corrplot) ## corrplot 0.84 loaded corrplot.mixed(cor(mtcars)) "],
["exercise.html", "Chapter 4 Exercise", " Chapter 4 Exercise Exercise 1: midwest is a dataset in ggplot2, and contains demographic information of midwest counties. Replicate the following scatterplot as close as you can. The variable for the x-axis, y-axis, color aesthetic, size aesthetic are area, poptotal, state, and popdensity. Excercise 2: Replicate the following barplot using the mpg dataset. Use theme(axis.text.x = element_text(angle=65, vjust=0.6)). Check why we need this theme by plotting with and without this theme. You also need width = 0.5 option in a geom to have more space between bar. "],
["base-r.html", "Chapter 5 Base R 5.1 Topics 5.2 Further reading 5.3 Interaction with R 5.4 R Objects and Variables 5.5 Data Structure 5.6 Vectors Come in Two Flavours 5.7 A Vector Has Three Properties 5.8 Attributes 5.9 Type Coercion (Conversion) 5.10 NA represents missing 5.11 Useful Functions for a vector 5.12 Exercise on vectors 5.13 Factors 5.14 Lists 5.15 Matrices and Arrays 5.16 Data Frames 5.17 Operators 5.18 Subsetting a Matrix and Array 5.19 Exercise 5.20 Combine Matrices by Columns or Rows 5.21 Names of the Columns and Rows of Matrices 5.22 Functions 5.23 An Example of Functions 5.24 User-Defined Functions 5.25 Exercise 5.26 Some Comments on Functions 5.27 Generating Sequences 5.28 Control Flow (if-else) 5.29 Control Flow (for) 5.30 Control Flow (for)", " Chapter 5 Base R suppressMessages(library(tidyverse)) 5.1 Topics R Objects and Variables Data Structure Sub-Setting Functions Control Flow (if, for, while) 5.2 Further reading Wickham, H. (2014). Advanced R. Chapman and Hall/CRC http://adv-r.had.co.nz This is a nice book to read after you become comfortable in base R (not required in this course) 5.3 Interaction with R R Console: for easy interactive exploration of ideas R Script file (.R): for sequence of R commands R markdown (.Rmd): for reproducible and dynamic reports 5.4 R Objects and Variables Everything in R is stored as an object, which is associated with a variable name. An object is a technical terminology defined in Object Oriented Programming (OOP). (OOP is an important concept but not in this class) A variable name can be assigned to an object using the assignment operator. # store a number to a variable named `a` a &lt;- 0.2 # print a a ## [1] 0.2 # store a vector to a variable named `b` b &lt;- c(1,4,9) # print b b ## [1] 1 4 9 z &lt;- 5 i &lt;- (z * 2 + 45)/2 i ## [1] 27.5 We can think of the assignment operation as “evaluate whatever is given on the right side of the operator, and assign (store) the result (an object of some type) of this evaluation in the variable whose name is given on the left side 5.5 Data Structure R has base data structures. Almost all other objects are built upon base data structures. R base data structures can be organized by their dimensionality: Dimension Homogeneous Heterogeneous 1D Atomic vector List 2D Matrix Data frame nD Array 5.6 Vectors Come in Two Flavours Atomic vectors (homogeneous) All elements of an atomic vector must be the same type. There are 6 types of an atomic vector Logical (TRUE or FALSE), integer, double, and character (+ rarely used complex and raw) Atomic vectors are usually created with c(), short for combine: a &lt;- c(TRUE, FALSE, T, F) # logical a &lt;- c(1L, 6L, 5L) # integer a &lt;- c(1, 2.5, 3.8) # double a &lt;- c(&quot;apple&quot;, &quot;orange&quot;) # character Lists (heterogeneous) Lists are different from atomic vectors because their elements can be of any type. List are created by list() &gt; x &lt;- list(1:3, &quot;a&quot;, c(TRUE, FALSE)) 5.7 A Vector Has Three Properties Type: typeof() returns the type of an object. typeof(c(1,2,3)) ## [1] &quot;double&quot; Length: length() returns the number of elements in a vector length(c(1,2,3)) ## [1] 3 Attributes: attributes() returns additional arbitrary metadata attributes(c(1,2,3)) ## NULL 5.8 Attributes All objects can have attributes to store metadata about the object. Attributes can be considered as a named list. Attributes can be accessed individually with attr() or all at once with attributes(). Names are attributes of a vector. You can name a vector in two ways: a &lt;- c(x=1,y=2,z=3) # when creating names(a) ## [1] &quot;x&quot; &quot;y&quot; &quot;z&quot; names(a) &lt;- c(&quot;l&quot;, &quot;m&quot;, &quot;n&quot;) # by modifying existing names a ## l m n ## 1 2 3 attributes(a) # names are attributes ## $names ## [1] &quot;l&quot; &quot;m&quot; &quot;n&quot; attributes(mtcars) ## $names ## [1] &quot;mpg&quot; &quot;cyl&quot; &quot;disp&quot; &quot;hp&quot; &quot;drat&quot; &quot;wt&quot; &quot;qsec&quot; &quot;vs&quot; &quot;am&quot; &quot;gear&quot; ## [11] &quot;carb&quot; ## ## $row.names ## [1] &quot;Mazda RX4&quot; &quot;Mazda RX4 Wag&quot; &quot;Datsun 710&quot; ## [4] &quot;Hornet 4 Drive&quot; &quot;Hornet Sportabout&quot; &quot;Valiant&quot; ## [7] &quot;Duster 360&quot; &quot;Merc 240D&quot; &quot;Merc 230&quot; ## [10] &quot;Merc 280&quot; &quot;Merc 280C&quot; &quot;Merc 450SE&quot; ## [13] &quot;Merc 450SL&quot; &quot;Merc 450SLC&quot; &quot;Cadillac Fleetwood&quot; ## [16] &quot;Lincoln Continental&quot; &quot;Chrysler Imperial&quot; &quot;Fiat 128&quot; ## [19] &quot;Honda Civic&quot; &quot;Toyota Corolla&quot; &quot;Toyota Corona&quot; ## [22] &quot;Dodge Challenger&quot; &quot;AMC Javelin&quot; &quot;Camaro Z28&quot; ## [25] &quot;Pontiac Firebird&quot; &quot;Fiat X1-9&quot; &quot;Porsche 914-2&quot; ## [28] &quot;Lotus Europa&quot; &quot;Ford Pantera L&quot; &quot;Ferrari Dino&quot; ## [31] &quot;Maserati Bora&quot; &quot;Volvo 142E&quot; ## ## $class ## [1] &quot;data.frame&quot; 5.9 Type Coercion (Conversion) All elements of a vector must belong to the same base data type. If that is not true, R will automatically force it by type coercion. v &lt;- c(4, 7, 23.5, 76.2, 80, &quot;rrt&quot;) v ## [1] &quot;4&quot; &quot;7&quot; &quot;23.5&quot; &quot;76.2&quot; &quot;80&quot; &quot;rrt&quot; typeof(v) ## [1] &quot;character&quot; Functions can automatically convert data type. sum(c(TRUE, FALSE, TRUE)) ## [1] 2 You can explicitly convert data type with as.character(), as.double(), as.integer(), and as.logical(). a &lt;- c(1,2,3) a ## [1] 1 2 3 b &lt;- as.character(a) b ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; 5.10 NA represents missing u &lt;- c(4, 6, NA, 2) u ## [1] 4 6 NA 2 k &lt;- c(TRUE, FALSE, FALSE, NA, TRUE) k ## [1] TRUE FALSE FALSE NA TRUE 5.11 Useful Functions for a vector 5.11.1 Generate a vector # we can manually type the element of a vector using c() a &lt;- c(1,2,3,4,5) a ## [1] 1 2 3 4 5 # c() also combine vectors a &lt;- c(1,2,3) b &lt;- c(4,5,6) c &lt;- c(a, b) c ## [1] 1 2 3 4 5 6 # k:n generates a vector whose elements are the sequence of numbers from k to n 1:10 ## [1] 1 2 3 4 5 6 7 8 9 10 # seq() generates regular sequence # seq(from, to) seq(1, 10) ## [1] 1 2 3 4 5 6 7 8 9 10 # seq(from, to, by) seq(1, 10, 2) ## [1] 1 3 5 7 9 # rep(x, times) replicates the values in x multiple times # x can be a number or vector # replicates 1 5 times rep(1, 5) ## [1] 1 1 1 1 1 # replicates c(1, 2) 5 times rep(c(1,2), 5) ## [1] 1 2 1 2 1 2 1 2 1 2 # each element of c(1,2) is repeated 5 times rep(c(1,2), each = 5) ## [1] 1 1 1 1 1 2 2 2 2 2 # rnorm(n, mean = 0, sd = 1) generates a vector of n random samples # from a normal distribution with specific mean and sd. rnorm(100) ## [1] -1.50064289 -0.09232959 1.51099445 0.30771100 -2.11872899 ## [6] -0.05685353 0.22309149 0.30422586 0.21779854 -0.06307553 ## [11] 0.56882567 -1.27383000 0.65382400 0.15746376 -0.95173637 ## [16] 1.25437218 -0.82893253 -0.24055288 -0.52348289 0.43142608 ## [21] -0.29066305 -1.08937099 -1.63957156 -1.15067507 -0.73545067 ## [26] -0.29453143 1.31037036 -0.78065229 0.17939720 -0.10468728 ## [31] 0.92749209 -1.82662432 -0.66500763 -0.22532103 -0.41288537 ## [36] -1.14619516 -1.88670771 0.82241267 -0.54732119 0.43038359 ## [41] 0.37592490 -0.19037314 -0.14435660 0.47530037 -0.44332282 ## [46] 1.49063643 -0.31107515 0.33437520 -0.74257018 0.73820044 ## [51] 2.21907859 -0.38155419 0.42722707 -0.41056292 -0.42869752 ## [56] 0.59940149 0.22416178 0.49632796 -1.18042672 0.33535533 ## [61] -0.23078888 -0.17379086 1.76907221 0.12846795 -0.56794428 ## [66] 0.42175278 -0.04368964 -0.18414430 -0.47615853 1.28149868 ## [71] -1.14456766 1.46138269 -0.71340480 -1.09779688 -0.66766269 ## [76] 0.60637631 -0.20806145 -1.45006030 0.31735634 -0.61015000 ## [81] 0.74043753 0.84555448 0.82591923 1.00859929 -0.54001287 ## [86] 0.03098207 -0.28437267 1.17788529 -0.27761821 0.95472443 ## [91] 0.24571510 0.20817059 -2.00108190 -0.71360374 0.72633346 ## [96] 0.17714022 -1.52187767 0.12955661 -0.42512501 1.60120381 qplot(rnorm(10000)) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. # runif(n, min, max) generates a vector of n random samples # from a uniform distribution whose limits are min and max. runif(100, 0, 1) ## [1] 0.943861250 0.056311908 0.633182602 0.710232072 0.825482420 ## [6] 0.613926861 0.892977876 0.362883682 0.252323278 0.154669180 ## [11] 0.935391706 0.779894701 0.949384364 0.842298174 0.006477969 ## [16] 0.512337480 0.816121064 0.245569136 0.317458130 0.143820596 ## [21] 0.713143229 0.455837973 0.090807271 0.427967532 0.270272379 ## [26] 0.180963991 0.636886485 0.869165608 0.796816674 0.207053073 ## [31] 0.435920799 0.385779594 0.810495143 0.999571885 0.816710621 ## [36] 0.347581698 0.977308467 0.971030333 0.044824908 0.515177422 ## [41] 0.234326150 0.028252058 0.415710200 0.781344965 0.760601581 ## [46] 0.716445617 0.187679717 0.263395456 0.618253534 0.483415370 ## [51] 0.394245577 0.175613471 0.489124339 0.407617667 0.588132814 ## [56] 0.924699242 0.872080879 0.521349988 0.899478856 0.077489302 ## [61] 0.214530362 0.303936806 0.238274281 0.138821038 0.951167596 ## [66] 0.634681566 0.951008948 0.590403458 0.704886384 0.026499815 ## [71] 0.945091792 0.615273389 0.954513302 0.334425333 0.490162405 ## [76] 0.494714282 0.111688823 0.341452840 0.954537064 0.353035126 ## [81] 0.586598723 0.201051355 0.691329050 0.620701057 0.362276409 ## [86] 0.485252253 0.350977099 0.580565370 0.141097489 0.503133415 ## [91] 0.747081937 0.725385464 0.765119377 0.766300231 0.163137351 ## [96] 0.673589961 0.993566201 0.684381658 0.209214546 0.514808541 qplot(runif(10000, 0, 1)) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. 5.11.2 Indexing or subsetting a Vector You can access a particular element of a vector through an index between square brackets or indexing (subsetting) operator. Positive integers return elements at the specified positions. x &lt;- c(2,3,4,5,6,7) x[c(3,1)] ## [1] 4 2 Negative integers omit elements at the specified positions: x[-c(3,1)] ## [1] 3 5 6 7 Logical vectors select elements where the corresponding logical value is TRUE. This logical indexing is very useful because we can subset a vector or dataframe based on conditions. x[c(TRUE, TRUE, FALSE, FALSE, TRUE, TRUE)] ## [1] 2 3 6 7 x &gt; 3 ## [1] FALSE FALSE TRUE TRUE TRUE TRUE # This is called a logical indexing, which is a very powerful tool. # &gt; : greater than (Logical Operators) x[x &gt; 3] ## [1] 4 5 6 7 x[x &gt; 3 &amp; x &lt; 5] ## [1] 4 # %in% operator # v1 %in% v2 returns a logical vector indicating # whether the elements of v1 are included in v2. c(1,2,3) %in% c(2,3,4,5,6) ## [1] FALSE TRUE TRUE a &lt;- c(1,2,3,4,5) a ## [1] 1 2 3 4 5 # we replace an element of a vector using the indexing and assignment operators. a[3] &lt;- 100 a ## [1] 1 2 100 4 5 a[c(1,5)] &lt;- 100 a ## [1] 100 2 100 4 100 a &lt;- c(1,2,3,NA,5,6,NA) a ## [1] 1 2 3 NA 5 6 NA # is.na indicates which elements are missing is.na(a) # returns TRUE when missing ## [1] FALSE FALSE FALSE TRUE FALSE FALSE TRUE # Type conversion: TRUE and FALSE will be converted into 1 and 0, respectively. # This expression answers the question: How many NSs are in a? sum(is.na(a)) ## [1] 2 # !x = not x (negation) !is.na(a) # returns TRUE when not missing ## [1] TRUE TRUE TRUE FALSE TRUE TRUE FALSE # This expression answers the question: How many non-NSs are in a? sum(!is.na(a)) ## [1] 5 # logical indexing a[is.na(a)] &lt;- 999 a ## [1] 1 2 3 999 5 6 999 # create a vector with names a &lt;- c(x = 1, y = 2, z = 3) a ## x y z ## 1 2 3 # named vector can be indexed using their names a[c(&quot;x&quot;, &quot;z&quot;)] ## x z ## 1 3 # R uses a &quot;recycling rule&quot; by repeating the shorter vector # In this example, R recycled c(TRUE, FALSE) to produce c(TRUE, FALSE, TRUE, FALSE) i &lt;- c(TRUE, FALSE) a &lt;- c(1,2,3,4) a[i] ## [1] 1 3 # R uses a &quot;recycling rule&quot; by repeating the shorter vector v1 &lt;- c(4,5,6,7) v2 &lt;- c(10,10) v1+v2 ## [1] 14 15 16 17 5.11.3 Arrange a vector # sort(x, decreasing = FALSE) # By default, sort() sorts ascending order. sort(c(5,6,4)) ## [1] 4 5 6 # sorts into descending order sort(c(5,6,4), decreasing = TRUE) ## [1] 6 5 4 # rev() provides a reversed version of its argument rev(c(5,6,4)) ## [1] 4 6 5 # rank() returns the sample ranks of the elements in a vector rank(c(5,6,4)) ## [1] 2 3 1 # order() returns a permutation which rearranges # its first argument into ascending or descending order. # What this means is order(c(5,6,4)) # 1) first sorts a vector in ascending order to produce c(4,5,6) # 2) and returns the indices of the sorted element in the original vector. # e.g., we have 3 first b/c the index of 4 in the original vector is 3 # e.g., we have 1 first b/c the index of 5 in the original vector is 1 # e.g., we have 2 first b/c the index of 6 in the original vector is 2 order(c(5,6,4)) ## [1] 3 1 2 # We use order() to sort a vector or dataframe a &lt;- c(5,6,4) a[order(a)] ## [1] 4 5 6 # sort a dataframe head(mtcars[order(mtcars$mpg), ]) ## mpg cyl disp hp drat wt qsec vs am gear carb ## Cadillac Fleetwood 10.4 8 472 205 2.93 5.250 17.98 0 0 3 4 ## Lincoln Continental 10.4 8 460 215 3.00 5.424 17.82 0 0 3 4 ## Camaro Z28 13.3 8 350 245 3.73 3.840 15.41 0 0 3 4 ## Duster 360 14.3 8 360 245 3.21 3.570 15.84 0 0 3 4 ## Chrysler Imperial 14.7 8 440 230 3.23 5.345 17.42 0 0 3 4 ## Maserati Bora 15.0 8 301 335 3.54 3.570 14.60 0 1 5 8 5.11.4 Vectorization of Functions One of the most powerful aspects of R is the vectorization of functions. Many R functions can be applied to a vector of values producing an equal-sized vector of results. v &lt;- c(1,4,25) sqrt(v) ## [1] 1 2 5 v &lt;- c(1,2,3) v^2 ## [1] 1 4 9 v1 &lt;- c(4,5,6,7) v2 &lt;- c(10,2,1,2) v1+v2 ## [1] 14 7 7 9 # R uses a &quot;recycling rule&quot; by repeating the shorter vector v1 &lt;- c(4,5,6,7) v2 &lt;- c(10,2) v1+v2 ## [1] 14 7 16 9 # mean will be subtracted from every element of v1 v1 &lt;- c(1,2,3,4) v1 - mean(v1) ## [1] -1.5 -0.5 0.5 1.5 5.11.5 Some more functions # table() creates a frequency table a &lt;- c(1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 4, 4) table(a) ## a ## 1 2 3 4 ## 2 3 3 5 # unique() returns a vector of unique elements unique(a) ## [1] 1 2 3 4 a &lt;- c(1,2,3,NA,5) # By default, mean() produces NA when there&#39;s NAs in a vector mean(a) ## [1] NA # na.rm = TRUE removes NAs before computation mean(a, na.rm = TRUE) ## [1] 2.75 5.12 Exercise on vectors mtcars is a dataframe about fuel economy of various cars. In the dataset, mpg represents miles per gallon. mtcars$mpg allows us to access the mpg variable in the mtcars dataframe. a &lt;- mtcars$mpg Calculate the length of the vector a. length(a) ## [1] 32 Calculate the mean of a using sum() and length() functions. sum(a)/length(a) ## [1] 20.09062 Calculate the mean of a using mean() function. mean(a) ## [1] 20.09062 Calculate the variance of a using sd() function. sd(a)^2 ## [1] 36.3241 Calculate the variance of a using var() function. var(a) ## [1] 36.3241 Calculate the variance of a by directly calculating the following expression: \\([(a_1 - \\bar{a})^2 + (a_2 - \\bar{a})^2 + ... (a_n - \\bar{a})^2]/(n-1) = \\frac{\\sum_{i=1}^{n}(a_i-\\bar{a})^2}{n-1}\\), where \\(a = (a_1, a_2, ... , a_n)\\) and \\(\\bar{a} = mean(a)\\) sum((a-mean(a))^2)/(length(a)-1) ## [1] 36.3241 Standardize the vector a, i.e., \\(z = \\frac{a-\\bar{a}}{sd(a)}\\). (a-mean(a))/sd(a) ## [1] 0.15088482 0.15088482 0.44954345 0.21725341 -0.23073453 ## [6] -0.33028740 -0.96078893 0.71501778 0.44954345 -0.14777380 ## [11] -0.38006384 -0.61235388 -0.46302456 -0.81145962 -1.60788262 ## [16] -1.60788262 -0.89442035 2.04238943 1.71054652 2.29127162 ## [21] 0.23384555 -0.76168319 -0.81145962 -1.12671039 -0.14777380 ## [26] 1.19619000 0.98049211 1.71054652 -0.71190675 -0.06481307 ## [31] -0.84464392 0.21725341 Use scale() function to standardize a and compare the results with your manual calculation. # check the help document of scale() by typing ?scale for more details scale(a) ## [,1] ## [1,] 0.15088482 ## [2,] 0.15088482 ## [3,] 0.44954345 ## [4,] 0.21725341 ## [5,] -0.23073453 ## [6,] -0.33028740 ## [7,] -0.96078893 ## [8,] 0.71501778 ## [9,] 0.44954345 ## [10,] -0.14777380 ## [11,] -0.38006384 ## [12,] -0.61235388 ## [13,] -0.46302456 ## [14,] -0.81145962 ## [15,] -1.60788262 ## [16,] -1.60788262 ## [17,] -0.89442035 ## [18,] 2.04238943 ## [19,] 1.71054652 ## [20,] 2.29127162 ## [21,] 0.23384555 ## [22,] -0.76168319 ## [23,] -0.81145962 ## [24,] -1.12671039 ## [25,] -0.14777380 ## [26,] 1.19619000 ## [27,] 0.98049211 ## [28,] 1.71054652 ## [29,] -0.71190675 ## [30,] -0.06481307 ## [31,] -0.84464392 ## [32,] 0.21725341 ## attr(,&quot;scaled:center&quot;) ## [1] 20.09062 ## attr(,&quot;scaled:scale&quot;) ## [1] 6.026948 Calculate the difference between the largest and smallest numbers in a. max(a)-min(a) ## [1] 23.5 # another solution diff(range(a)) ## [1] 23.5 Normalize the vector a, i.e., \\(n = \\frac{(x-min(x))}{(max(x)-min(x))}\\). # your maximum value will be 1, and minimum value will be 0. (a-min(a))/(max(a)-min(a)) ## [1] 0.4510638 0.4510638 0.5276596 0.4680851 0.3531915 0.3276596 0.1659574 ## [8] 0.5957447 0.5276596 0.3744681 0.3148936 0.2553191 0.2936170 0.2042553 ## [15] 0.0000000 0.0000000 0.1829787 0.9361702 0.8510638 1.0000000 0.4723404 ## [22] 0.2170213 0.2042553 0.1234043 0.3744681 0.7191489 0.6638298 0.8510638 ## [29] 0.2297872 0.3957447 0.1957447 0.4680851 Plot the histogram of a using qplot(). qplot(a) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. # To set aesthetics, wrap in I() qplot(a, color = I(&quot;red&quot;), fill = I(&quot;blue&quot;)) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. How many elements in a are larger than 20? (use length()) # creates a logical vector in which TRUE indicates the element that is larger than 20 a&gt;20 ## [1] TRUE TRUE TRUE TRUE FALSE FALSE FALSE TRUE TRUE FALSE FALSE ## [12] FALSE FALSE FALSE FALSE FALSE FALSE TRUE TRUE TRUE TRUE FALSE ## [23] FALSE FALSE FALSE TRUE TRUE TRUE FALSE FALSE FALSE TRUE # This is a logical indexing where the logical vector # within the subsetting operator (i.e., []) will create a vector with elements larger than 20. a[a&gt;20] ## [1] 21.0 21.0 22.8 21.4 24.4 22.8 32.4 30.4 33.9 21.5 27.3 26.0 30.4 21.4 length(a[a&gt;20]) ## [1] 14 How many elements in a are larger than 20? (use sum()) # same result # this happens because of &quot;vectorization&quot; and &quot;type conversion&quot; sum(a&gt;20) ## [1] 14 txhousing is a tibble in ggplot2 containing information about the housing market in Texas provided by the TAMU real estate center. In the dataset, median represents median sale price. txhousing$median allows us to access the median variable in the txhousing tibble (or dataframe). b &lt;- txhousing$median Calculate the length of the vector b. how many missing values (or NAs) are in b? Calculate the mean of b using sum() and length() functions. Calculate the mean of b using mean() function. Are the two means same? If not, Why? How do we get the same result? Calculate the variance of b using sd() function. Calculate the variance of b using var() function. Plot the histogram of b using qplot(). Create a new vector c by removing all missing from b. (Using c) What percentage of houses has median sale price larger than $200000? 5.13 Factors 5.13.1 What is a factor? Factors are used to represent categorical data (e.g., gender, states). Factors are stored as a vector of integer values associated with a set of character values (levels) to use when the factor is displayed. Factor have two attributes the class(), “factor”, which make factors behave differently from regular integer vectors, and the levels(), which defines the set of allowed values. 5.13.2 Creating a factor The function factor() is used to encode a numeric or character vector as a factor. # levels are the set of allowed values f1 &lt;- factor(c(2,1,1,3,2,1,1)) f1 ## [1] 2 1 1 3 2 1 1 ## Levels: 1 2 3 Factors are built on top of integers, and have a levels attribute typeof(f1) ## [1] &quot;integer&quot; attributes(f1) ## $levels ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; ## ## $class ## [1] &quot;factor&quot; levels() displays the levels of a factor levels(f1) ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; The factor’s level is a character vector. # test for objects of type &quot;character&quot; is.character(levels(f1)) ## [1] TRUE More test functions in R https://r4ds.had.co.nz/vectors.html We can change levels levels(f1) &lt;- c(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;) f1 ## [1] two one one three two one one ## Levels: one two three By default, the level of a factor will be displayed in alphabetical order. f2 &lt;- factor(c(&quot;Dec&quot;, &quot;Apr&quot;, &quot;Jan&quot;, &quot;Mar&quot;)) f2 ## [1] Dec Apr Jan Mar ## Levels: Apr Dec Jan Mar sort(f2) ## [1] Apr Dec Jan Mar ## Levels: Apr Dec Jan Mar levels option can be used to change the order in which the levels will be displayed from their default sorted order month_levels &lt;- c( &quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot; ) f3 &lt;- factor(c(&quot;Dec&quot;, &quot;Apr&quot;, &quot;Jan&quot;, &quot;Mar&quot;), levels = month_levels) f3 ## [1] Dec Apr Jan Mar ## Levels: Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec # In many cases, this is the result that we expect. sort(f3) ## [1] Jan Mar Apr Dec ## Levels: Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec table(f3) ## f3 ## Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec ## 1 0 1 1 0 0 0 0 0 0 0 1 table(f2) ## f2 ## Apr Dec Jan Mar ## 1 1 1 1 5.13.3 unordered vs ordered factor Although the levels of a factor created by the factor() function has an order for displaying, the factor created by the factor() is called an unordered factor in the sense that the factor does not have any meaningful ordering structure. Comparison operators will not work with the unordered factor. Sometimes, we want to specify the meaningful order of a factor by creating an ordered factor. # the default level is in alphabetical order f4 &lt;- factor(c(&quot;high&quot;, &quot;low&quot;, &quot;medium&quot;, &quot;medium&quot;, &quot;high&quot;)) f4 ## [1] high low medium medium high ## Levels: high low medium sort(f4) ## [1] high high low medium medium ## Levels: high low medium f5 &lt;- factor(c(&quot;high&quot;, &quot;low&quot;, &quot;medium&quot;, &quot;medium&quot;, &quot;high&quot;), levels = c(&quot;low&quot;, &quot;medium&quot;, &quot;high&quot;)) f5 ## [1] high low medium medium high ## Levels: low medium high sort(f5) ## [1] low medium medium high high ## Levels: low medium high min(f5) and f[1] &lt; f[3] will produce error. With ordered = TRUE option, the levels should be regarded as ordered. f6 &lt;- factor(c(&quot;high&quot;, &quot;low&quot;, &quot;medium&quot;, &quot;medium&quot;, &quot;high&quot;), levels = c(&quot;low&quot;, &quot;medium&quot;, &quot;high&quot;), ordered = TRUE) f6 ## [1] high low medium medium high ## Levels: low &lt; medium &lt; high min(f6) ## [1] low ## Levels: low &lt; medium &lt; high f6[1] &gt; f6[2] ## [1] TRUE ordered() function also creates an ordered factor. f7 &lt;- ordered(c(&quot;high&quot;, &quot;low&quot;, &quot;medium&quot;, &quot;medium&quot;, &quot;high&quot;), levels = c(&quot;low&quot;, &quot;medium&quot;, &quot;high&quot;)) f7 ## [1] high low medium medium high ## Levels: low &lt; medium &lt; high 5.13.4 Why factors? Factors are an efficient way to store character values, because each unique character value is stored only once, and the factor itself is stored as an integer vector. Factors prevent typo because they only allow us to input the pre-defined values. Factors allow us to encode ordering structure. 5.13.5 Some more comments Be careful. Many base R functions automatically convert character vectors into factors. To suppress this default behavior, use stringsAsFactors = FALSE option within a function. You can explicitly convert data type with as.character(), as.double(), as.integer(), and as.logical(). 5.13.6 Exercise You have the following responses of a five-point likert scale survey item: x &lt;- c(&quot;Agree&quot;, &quot;Disagree&quot;, &quot;Neutral&quot;, &quot;Agree&quot; ,&quot;Agree&quot;, &quot;Strongly disagree&quot;, &quot;Neutral&quot;). Create an ordered factor for the five point likert scale responses (Notice that you don’t have “Strongly agree” in x, but include “Strongly agree” in your factor level). x &lt;- c(&quot;Agree&quot;, &quot;Disagree&quot;, &quot;Neutral&quot;, &quot;Agree&quot; ,&quot;Agree&quot;, &quot;Strongly disagree&quot;, &quot;Neutral&quot;) # you may want to this factor(x, levels = c(&quot;Strongly disagree&quot;, &quot;Disagree&quot;, &quot;Neutral&quot;, &quot;Agree&quot;, &quot;Strongly agree&quot;)) ## [1] Agree Disagree Neutral Agree ## [5] Agree Strongly disagree Neutral ## Levels: Strongly disagree Disagree Neutral Agree Strongly agree # not this factor(x) ## [1] Agree Disagree Neutral Agree ## [5] Agree Strongly disagree Neutral ## Levels: Agree Disagree Neutral Strongly disagree Using the following character vector x = c(&quot;male&quot;, &quot;male&quot;, &quot;female&quot;, &quot;male&quot;, &quot;female&quot;), create a factor with levels reversed from its default levels order. x = c(&quot;male&quot;, &quot;male&quot;, &quot;female&quot;, &quot;male&quot;, &quot;female&quot;) # by default, female become first factor(x) ## [1] male male female male female ## Levels: female male # What I&#39;ve asked you is to change the default alphabetical order using levels options. factor(x, levels = c(&quot;male&quot;, &quot;female&quot;)) ## [1] male male female male female ## Levels: male female Run the following code and explain what the code is doing. # I just wanted to introduce &#39;cut()` function set.seed(7) x &lt;- rnorm(100) cut(x, breaks = quantile(x)) ## [1] (0.72,2.72] (-1.79,-0.559] (-1.79,-0.559] (-0.559,0.106] ## [5] (-1.79,-0.559] (-1.79,-0.559] (0.72,2.72] (-0.559,0.106] ## [9] (0.106,0.72] (0.72,2.72] (0.106,0.72] (0.72,2.72] ## [13] (0.72,2.72] (0.106,0.72] (0.72,2.72] (0.106,0.72] ## [17] (-1.79,-0.559] (-0.559,0.106] (-0.559,0.106] (0.72,2.72] ## [21] (0.72,2.72] (0.106,0.72] (0.72,2.72] (-1.79,-0.559] ## [25] (0.72,2.72] (0.106,0.72] (0.72,2.72] (0.106,0.72] ## [29] (-1.79,-0.559] (-0.559,0.106] (-1.79,-0.559] (0.106,0.72] ## [33] (0.106,0.72] (-0.559,0.106] (-0.559,0.106] (-1.79,-0.559] ## [37] (0.72,2.72] (-1.79,-0.559] (-0.559,0.106] (0.106,0.72] ## [41] (0.72,2.72] (-1.79,-0.559] (-0.559,0.106] (-1.79,-0.559] ## [45] (-0.559,0.106] (-0.559,0.106] (0.72,2.72] (0.106,0.72] ## [49] (-0.559,0.106] (0.72,2.72] (-0.559,0.106] (-0.559,0.106] ## [53] (0.106,0.72] (0.72,2.72] (0.72,2.72] (0.106,0.72] ## [57] (-1.79,-0.559] (0.106,0.72] (0.106,0.72] (-1.79,-0.559] ## [61] (-0.559,0.106] (0.106,0.72] (0.106,0.72] (0.106,0.72] ## [65] (0.106,0.72] (0.72,2.72] (0.72,2.72] (0.72,2.72] ## [69] (0.72,2.72] (0.106,0.72] (0.106,0.72] (-1.79,-0.559] ## [73] (-1.79,-0.559] (-1.79,-0.559] (-1.79,-0.559] (-1.79,-0.559] ## [77] (-1.79,-0.559] (-0.559,0.106] (-0.559,0.106] (0.72,2.72] ## [81] (0.106,0.72] (-0.559,0.106] (-0.559,0.106] (-0.559,0.106] ## [85] (-1.79,-0.559] (-0.559,0.106] (-0.559,0.106] (-0.559,0.106] ## [89] &lt;NA&gt; (0.106,0.72] (0.72,2.72] (-1.79,-0.559] ## [93] (0.106,0.72] (0.106,0.72] (0.72,2.72] (-1.79,-0.559] ## [97] (0.72,2.72] (-1.79,-0.559] (-0.559,0.106] (-0.559,0.106] ## Levels: (-1.79,-0.559] (-0.559,0.106] (0.106,0.72] (0.72,2.72] 5.14 Lists 5.14.1 What is a list? A list is a one-dimensional heterogeneous data structure. _ Because a list is a one-dimensional data structure, we can index the element of a list using a single number. Unlike a vector, a list is a heterogeneous data structure, meaning that the element of a list can be any object in R. 5.14.2 Creating a list list() is used to create a list. x &lt;- list(1:6, &quot;a&quot;, c(TRUE, TRUE, FALSE), c(1.2, 3.3, 4.6, 6.6)) x ## [[1]] ## [1] 1 2 3 4 5 6 ## ## [[2]] ## [1] &quot;a&quot; ## ## [[3]] ## [1] TRUE TRUE FALSE ## ## [[4]] ## [1] 1.2 3.3 4.6 6.6 # str() display the internal structure of an R object str(x) ## List of 4 ## $ : int [1:6] 1 2 3 4 5 6 ## $ : chr &quot;a&quot; ## $ : logi [1:3] TRUE TRUE FALSE ## $ : num [1:4] 1.2 3.3 4.6 6.6 typeof(x) ## [1] &quot;list&quot; 5.14.3 Why lists? Because of its flexible structure, many R functions store their outputs as a list, and return the list. # In R, lm() is a function that fits a regression model to data. # In the following R expression, &#39;mpg&#39; is a dependent variable # and `disp` and `cyl` are independent variable. fit &lt;- lm(mpg ~ disp + cyl, data = mtcars) fit ## ## Call: ## lm(formula = mpg ~ disp + cyl, data = mtcars) ## ## Coefficients: ## (Intercept) disp cyl ## 34.66099 -0.02058 -1.58728 typeof(fit) ## [1] &quot;list&quot; str(fit) ## List of 12 ## $ coefficients : Named num [1:3] 34.661 -0.0206 -1.5873 ## ..- attr(*, &quot;names&quot;)= chr [1:3] &quot;(Intercept)&quot; &quot;disp&quot; &quot;cyl&quot; ## $ residuals : Named num [1:32] -0.844 -0.844 -3.289 1.573 4.147 ... ## ..- attr(*, &quot;names&quot;)= chr [1:32] &quot;Mazda RX4&quot; &quot;Mazda RX4 Wag&quot; &quot;Datsun 710&quot; &quot;Hornet 4 Drive&quot; ... ## $ effects : Named num [1:32] -113.65 -28.44 -6.81 2.04 4.06 ... ## ..- attr(*, &quot;names&quot;)= chr [1:32] &quot;(Intercept)&quot; &quot;disp&quot; &quot;cyl&quot; &quot;&quot; ... ## $ rank : int 3 ## $ fitted.values: Named num [1:32] 21.8 21.8 26.1 19.8 14.6 ... ## ..- attr(*, &quot;names&quot;)= chr [1:32] &quot;Mazda RX4&quot; &quot;Mazda RX4 Wag&quot; &quot;Datsun 710&quot; &quot;Hornet 4 Drive&quot; ... ## $ assign : int [1:3] 0 1 2 ## $ qr :List of 5 ## ..$ qr : num [1:32, 1:3] -5.657 0.177 0.177 0.177 0.177 ... ## .. ..- attr(*, &quot;dimnames&quot;)=List of 2 ## .. .. ..$ : chr [1:32] &quot;Mazda RX4&quot; &quot;Mazda RX4 Wag&quot; &quot;Datsun 710&quot; &quot;Hornet 4 Drive&quot; ... ## .. .. ..$ : chr [1:3] &quot;(Intercept)&quot; &quot;disp&quot; &quot;cyl&quot; ## .. ..- attr(*, &quot;assign&quot;)= int [1:3] 0 1 2 ## ..$ qraux: num [1:3] 1.18 1.09 1.19 ## ..$ pivot: int [1:3] 1 2 3 ## ..$ tol : num 1e-07 ## ..$ rank : int 3 ## ..- attr(*, &quot;class&quot;)= chr &quot;qr&quot; ## $ df.residual : int 29 ## $ xlevels : Named list() ## $ call : language lm(formula = mpg ~ disp + cyl, data = mtcars) ## $ terms :Classes &#39;terms&#39;, &#39;formula&#39; language mpg ~ disp + cyl ## .. ..- attr(*, &quot;variables&quot;)= language list(mpg, disp, cyl) ## .. ..- attr(*, &quot;factors&quot;)= int [1:3, 1:2] 0 1 0 0 0 1 ## .. .. ..- attr(*, &quot;dimnames&quot;)=List of 2 ## .. .. .. ..$ : chr [1:3] &quot;mpg&quot; &quot;disp&quot; &quot;cyl&quot; ## .. .. .. ..$ : chr [1:2] &quot;disp&quot; &quot;cyl&quot; ## .. ..- attr(*, &quot;term.labels&quot;)= chr [1:2] &quot;disp&quot; &quot;cyl&quot; ## .. ..- attr(*, &quot;order&quot;)= int [1:2] 1 1 ## .. ..- attr(*, &quot;intercept&quot;)= int 1 ## .. ..- attr(*, &quot;response&quot;)= int 1 ## .. ..- attr(*, &quot;.Environment&quot;)=&lt;environment: R_GlobalEnv&gt; ## .. ..- attr(*, &quot;predvars&quot;)= language list(mpg, disp, cyl) ## .. ..- attr(*, &quot;dataClasses&quot;)= Named chr [1:3] &quot;numeric&quot; &quot;numeric&quot; &quot;numeric&quot; ## .. .. ..- attr(*, &quot;names&quot;)= chr [1:3] &quot;mpg&quot; &quot;disp&quot; &quot;cyl&quot; ## $ model :&#39;data.frame&#39;: 32 obs. of 3 variables: ## ..$ mpg : num [1:32] 21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ... ## ..$ disp: num [1:32] 160 160 108 258 360 ... ## ..$ cyl : num [1:32] 6 6 4 6 8 6 8 4 4 6 ... ## ..- attr(*, &quot;terms&quot;)=Classes &#39;terms&#39;, &#39;formula&#39; language mpg ~ disp + cyl ## .. .. ..- attr(*, &quot;variables&quot;)= language list(mpg, disp, cyl) ## .. .. ..- attr(*, &quot;factors&quot;)= int [1:3, 1:2] 0 1 0 0 0 1 ## .. .. .. ..- attr(*, &quot;dimnames&quot;)=List of 2 ## .. .. .. .. ..$ : chr [1:3] &quot;mpg&quot; &quot;disp&quot; &quot;cyl&quot; ## .. .. .. .. ..$ : chr [1:2] &quot;disp&quot; &quot;cyl&quot; ## .. .. ..- attr(*, &quot;term.labels&quot;)= chr [1:2] &quot;disp&quot; &quot;cyl&quot; ## .. .. ..- attr(*, &quot;order&quot;)= int [1:2] 1 1 ## .. .. ..- attr(*, &quot;intercept&quot;)= int 1 ## .. .. ..- attr(*, &quot;response&quot;)= int 1 ## .. .. ..- attr(*, &quot;.Environment&quot;)=&lt;environment: R_GlobalEnv&gt; ## .. .. ..- attr(*, &quot;predvars&quot;)= language list(mpg, disp, cyl) ## .. .. ..- attr(*, &quot;dataClasses&quot;)= Named chr [1:3] &quot;numeric&quot; &quot;numeric&quot; &quot;numeric&quot; ## .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:3] &quot;mpg&quot; &quot;disp&quot; &quot;cyl&quot; ## - attr(*, &quot;class&quot;)= chr &quot;lm&quot; 5.14.4 Subsetting a List Subsetting a list works in the same way as subsetting an atomic vector. Using [ ] will always return a list; [[ ]] and $ let you pull out the components of the list. my.lst &lt;- list(stud.id=34453, # creat a list stud.name=&quot;John&quot;, stud.marks=c(14.3,12,15,19)) my.lst ## $stud.id ## [1] 34453 ## ## $stud.name ## [1] &quot;John&quot; ## ## $stud.marks ## [1] 14.3 12.0 15.0 19.0 # [ ] extracts a sub-list my.lst[1] ## $stud.id ## [1] 34453 typeof(my.lst[1]) ## [1] &quot;list&quot; # [[ ]] extracts the value of an individual element my.lst[[1]] ## [1] 34453 typeof(my.lst[[1]]) ## [1] &quot;double&quot; # my.lst[[3]] will index the third element of a list, which is a numeric vector # my.lst[[3]][2] will index the second element of the numeric vector my.lst[[3]][2] ## [1] 12 # In the case of lists with named elements # $ extracts the value of an individual element my.lst$stud.id ## [1] 34453 typeof(my.lst$stud.id) ## [1] &quot;double&quot; 5.14.5 Exercise fit is a list that contains the outputs of the lm() function for linear regression. Explore the structure of the fit object using str(). fit &lt;- lm(mpg ~ disp + cyl, data = mtcars) fit ## ## Call: ## lm(formula = mpg ~ disp + cyl, data = mtcars) ## ## Coefficients: ## (Intercept) disp cyl ## 34.66099 -0.02058 -1.58728 Extract the coefficient of “Intercept” with indexing using a positive integer. # fit$coefficient is a vector fit$coefficients ## (Intercept) disp cyl ## 34.66099474 -0.02058363 -1.58727681 # So, we can subset the first element using the following expression fit$coefficients[1] ## (Intercept) ## 34.66099 Extract the coefficient of “Intercept” with indexing using a name. # We can also use the name of element for indexing. fit$coefficients[&quot;(Intercept)&quot;] ## (Intercept) ## 34.66099 5.14.6 Data frames A data frame is a list of equal-length vectors. head(iris) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa typeof(iris) ## [1] &quot;list&quot; str(iris) ## &#39;data.frame&#39;: 150 obs. of 5 variables: ## $ Sepal.Length: num 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... ## $ Sepal.Width : num 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ... ## $ Petal.Length: num 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... ## $ Petal.Width : num 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ... ## $ Species : Factor w/ 3 levels &quot;setosa&quot;,&quot;versicolor&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... 5.14.7 The apply family of functions The apply() family of functions refers to apply(), lapply(), sapply(), vapply(), mapply(), rapply(), and tapply(). Why do we need them? They will make your code much shorter by replacing your own copy and paste # A motivating example: check the number of missing values in each column of the following data frame &#39;m&#39; m &lt;- data.frame(matrix(c(1,2,3,4,NA,6,7,NA,NA,NA,NA,NA), ncol = 4)) m ## X1 X2 X3 X4 ## 1 1 4 7 NA ## 2 2 NA NA NA ## 3 3 6 NA NA sum(is.na(m$X1)) ## [1] 0 sum(is.na(m$X2)) ## [1] 1 sum(is.na(m$X3)) ## [1] 2 sum(is.na(m$X4)) ## [1] 3 lapply(X, FUN) X = a list object in R FUN = a function in R lapply() takes a function (FUN) applies it to each element of a list (X) and returns the results in the form of a list # This one line of code will still work even when the number of columns are 1000 or more. lapply(m, function(x) sum(is.na(x))) ## $X1 ## [1] 0 ## ## $X2 ## [1] 1 ## ## $X3 ## [1] 2 ## ## $X4 ## [1] 3 # lapply() returns a list, whereas sapply() returns a vector, matrix, or array. sapply(m, function(x) sum(is.na(x))) ## X1 X2 X3 X4 ## 0 1 2 3 5.14.8 Exercise How many columns in the bfi dataset have missing values more than 20? library(psych) ## ## Attaching package: &#39;psych&#39; ## The following objects are masked from &#39;package:ggplot2&#39;: ## ## %+%, alpha head(bfi) ## A1 A2 A3 A4 A5 C1 C2 C3 C4 C5 E1 E2 E3 E4 E5 N1 N2 N3 N4 N5 O1 O2 O3 ## 61617 2 4 3 4 4 2 3 3 4 4 3 3 3 4 4 3 4 2 2 3 3 6 3 ## 61618 2 4 5 2 5 5 4 4 3 4 1 1 6 4 3 3 3 3 5 5 4 2 4 ## 61620 5 4 5 4 4 4 5 4 2 5 2 4 4 4 5 4 5 4 2 3 4 2 5 ## 61621 4 4 6 5 5 4 4 3 5 5 5 3 4 4 4 2 5 2 4 1 3 3 4 ## 61622 2 3 3 4 5 4 4 5 3 2 2 2 5 4 5 2 3 4 4 3 3 3 4 ## 61623 6 6 5 6 5 6 6 6 1 3 2 1 6 5 6 3 5 2 2 3 4 3 5 ## O4 O5 gender education age ## 61617 4 3 1 NA 16 ## 61618 3 3 2 NA 18 ## 61620 5 2 2 NA 17 ## 61621 3 5 2 NA 17 ## 61622 3 3 1 NA 17 ## 61623 6 1 2 3 21 5.14.9 More resources For more details about a vector, factor, and list, see Ch20 in R for Data Science (https://r4ds.had.co.nz/vectors.html). For more details about the apply family of functions, see a nice introduction in Data Camp (https://www.datacamp.com/community/tutorials/r-tutorial-apply-family). 5.15 Matrices and Arrays matrices and arrays are implemented as vectors with special attributes Adding a dim() attribute to an atomic vector allows it to behave like a multi-dimensional array. a &lt;- 1:6 a ## [1] 1 2 3 4 5 6 # Get or set specific attributes of an object. attr(a, &quot;dim&quot;) &lt;- c(3,2) a ## [,1] [,2] ## [1,] 1 4 ## [2,] 2 5 ## [3,] 3 6 # by default, a matrix is filled by column a &lt;- matrix(1:6, ncol=3, nrow=2) a ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 2 4 6 a &lt;- matrix(1:6, ncol=3) a ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 2 4 6 # a matrix can be filled by row using `byrow = TRUE` a &lt;- matrix(1:6, ncol=3, nrow=2, byrow = TRUE) a ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 4 5 6 attributes(a) ## $dim ## [1] 2 3 dim(a) ## [1] 2 3 b &lt;- array(1:12, c(2,3,2)) b ## , , 1 ## ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 2 4 6 ## ## , , 2 ## ## [,1] [,2] [,3] ## [1,] 7 9 11 ## [2,] 8 10 12 dim(b) ## [1] 2 3 2 length() generalises to nrow() and ncol() for matrices, and dim() for arrays. names() generalises to rownames() and colnames() for matrices, and dimnames(), a list of character vectors, for arrays. results &lt;- matrix(c(10, 30, 40, 50, 43, 56, 21, 30), 2, 4, byrow = TRUE) colnames(results) &lt;- c(&quot;1qrt&quot;, &quot;2qrt&quot;, &quot;3qrt&quot;, &quot;4qrt&quot;) rownames(results) &lt;- c(&quot;store1&quot;, &quot;store2&quot;) results ## 1qrt 2qrt 3qrt 4qrt ## store1 10 30 40 50 ## store2 43 56 21 30 5.16 Data Frames A data frame is a list of equal-length vectors. A data frame is the most common way of storing data in R. df &lt;- data.frame(x=1:3, y=c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) df ## x y ## 1 1 a ## 2 2 b ## 3 3 c # display the internal structure of an R object str(df) ## &#39;data.frame&#39;: 3 obs. of 2 variables: ## $ x: int 1 2 3 ## $ y: Factor w/ 3 levels &quot;a&quot;,&quot;b&quot;,&quot;c&quot;: 1 2 3 data.frame() converts strings into factors by default. This default setting can cause serious problems in some cases. stringAsFactors = FALSE suppresses this default setting. Using str() to check data types is always a good practice. df &lt;- data.frame(x=1:3, y=c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), stringsAsFactors = FALSE) str(df) # display the internal structure of an R object ## &#39;data.frame&#39;: 3 obs. of 2 variables: ## $ x: int 1 2 3 ## $ y: chr &quot;a&quot; &quot;b&quot; &quot;c&quot; 5.17 Operators Arithmetic Operators Operator Description + addition - subtraction * multiplication / division ^ or ** exponentiation Logical Operators Operator Description &lt; less than &lt;= less than or equal to &gt; greater than &gt;= greater than equal to == exactly equal to != not equal to !x Not x x|y x OR y x&amp;Y x AND y 1 == 2 ## [1] FALSE &quot;a&quot; != &quot;b&quot; ## [1] TRUE (1 == 2) | (&quot;a&quot; != &quot;b&quot;) ## [1] TRUE (1 == 2) &amp; (&quot;a&quot; != &quot;b&quot;) ## [1] FALSE 5.18 Subsetting a Matrix and Array You can supply 1d index for each dimension. a &lt;- matrix(1:9, nrow = 3) colnames(a) &lt;- c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;) a ## A B C ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 a[c(TRUE, FALSE, TRUE), c(&quot;B&quot;, &quot;A&quot;)] ## B A ## [1,] 4 1 ## [2,] 6 3 a[1, c(2,3)] ## B C ## 4 7 # If you omit any dimension, you obtain full columns or rows a[2,] ## A B C ## 2 5 8 a[,3] ## [1] 7 8 9 a ## A B C ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 a &gt; 3 ## A B C ## [1,] FALSE TRUE TRUE ## [2,] FALSE TRUE TRUE ## [3,] FALSE TRUE TRUE a[a&gt;3] &lt;- NA a ## A B C ## [1,] 1 NA NA ## [2,] 2 NA NA ## [3,] 3 NA NA 5.19 Exercise mtcars is a fuel economy dataset. Subset the mtcars dataset such that you only keep mpg, cyl, and gear variables with 6 cylinders. Subset the mtcars dataset such that you only keep mpg, cyl, disp, hp, dart, wt, qsec, and am variables with 4 or 6 cylinders. Subset the mtcars dataset such that you only keep mpg, cyl, disp, hp, dart, wt, qsec, and am variables with 4 or 6 cylinders, and mpg larger than 20. 5.20 Combine Matrices by Columns or Rows # combine by columns cbind(a,a) ## A B C A B C ## [1,] 1 NA NA 1 NA NA ## [2,] 2 NA NA 2 NA NA ## [3,] 3 NA NA 3 NA NA # combine by rows rbind(a,a) ## A B C ## [1,] 1 NA NA ## [2,] 2 NA NA ## [3,] 3 NA NA ## [4,] 1 NA NA ## [5,] 2 NA NA ## [6,] 3 NA NA 5.21 Names of the Columns and Rows of Matrices colnames(a) ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; rownames(a) &lt;- c(&quot;D&quot;, &quot;E&quot;, &quot;F&quot;) rownames(a) ## [1] &quot;D&quot; &quot;E&quot; &quot;F&quot; 5.22 Functions R functions are a special type of R object designed to carry out some operation. R functions, like mathematical functions, are applied to some set of arguments and produce a result. output = function_name(argument) In R, both the arguments that we provide when we call the function and the result of the function execution are R objects whose type will depend on the function. R functions range from simple objects implementing some standard calculation, e.g. calculating the square root of a number, to more complex functions that can obtain some model of a dataset, e.g. a neural network. 5.23 An Example of Functions # call (execute or run) the mean() function mean(c(1,2,3,4)) ## [1] 2.5 # a will store the object returned by the mean() a &lt;- mean(c(1,2,3,4)) # mean() will not work with NA mean(c(1,2,NA,4)) ## [1] NA # When na.rm = TRUE, NA will be removed before computation mean(c(1,2,NA,4), na.rm = TRUE) ## [1] 2.333333 5.24 User-Defined Functions We can write our own functions easily function.name &lt;- function(arg1, arg2, arg3){body} # Define se() function that calculate the standard error se &lt;- function(x) { v &lt;- var(x) n &lt;- length(x) return(sqrt(v/n)) } mySample &lt;- rnorm(n=100, mean=20, sd=4) se(mySample) ## [1] 0.3795976 5.25 Exercise The follow code will generate two numeric vectors randomly sampled from N(0,1) and N(3,2). x1 &lt;- rnorm(100, mean=0, sd=1) # generate 100 random numbers from Normal(0,1) x2 &lt;- rnorm(100, mean=3, sd=2) # generate 100 random numbers from Normal(3,2) Write your own function that returns (simplified) Cohen’s d = \\(\\frac{mean(x_2)-mean(x_1)}{sd(x_1)}\\). Specifically, your function should get the above two vectors x1 and x2 as function arguments and return d. For fun, let’s use your own name as the name of this function. Check whether your function actually work by running your_name(x1,x2). 5.26 Some Comments on Functions Functions are a fundamental building block of R. We can creat our own functions, but we usually use functions made by others. Packages are a collection of functions made by others. In many cases, our job is to build a pipeline of data flow by connecting many available functions. To do that, we have to handle the input objects (argument) and output objects (returned objects) of functions, which requires knowledge about data structure (e.g., creating, subsetting). 5.27 Generating Sequences # creating a vector containing integers between 1 and 10 1:10 ## [1] 1 2 3 4 5 6 7 8 9 10 5:0 ## [1] 5 4 3 2 1 0 seq(from=1, to=3, by=0.5) ## [1] 1.0 1.5 2.0 2.5 3.0 # rep() replicates each term in formula rep(5,3) ## [1] 5 5 5 rep(1:2, 3) ## [1] 1 2 1 2 1 2 rep(1:2, each=3) ## [1] 1 1 1 2 2 2 # gl() generates sequences involving factors # gl(k,n), k = the number of levels, # n = the number of repetitions. gl(5,3) ## [1] 1 1 1 2 2 2 3 3 3 4 4 4 5 5 5 ## Levels: 1 2 3 4 5 5.28 Control Flow (if-else) Control flow = the order in which individual statement are executed (or evaluated) Selection if (condition) expression: If the condition is TRUE, the expression gets executed. if (condition) expression1 else expression2: The else part is only executed if the condition if FALSE. x &lt;- -5 if (x&gt;0) { print(&quot;Positive number&quot;) } else { print(&quot;Negative number&quot;) } ## [1] &quot;Negative number&quot; 5.29 Control Flow (for) for (value in sequence) {statements} for loop allows us to repeat (loop) through the elements in a vector and run the code inside the block within curly brackets. for (i in 1:3) { print(i^2) } ## [1] 1 ## [1] 4 ## [1] 9 5.30 Control Flow (for) # count the number of even numbers x &lt;- c(2,5,3,9,8,11,6) count &lt;- 0 for (val in x) { if(val %% 2 == 0) count = count+1 } print(count) ## [1] 3 "],
["base-r-quiz.html", "Chapter 6 Base R Quiz", " Chapter 6 Base R Quiz 6.0.1 Dataset1: diamonds is a dataset in ggplot2 containing the prices and other attributes of almost 54,000 diamonds. In the dataset, price is the price of diamonds in US dollars, and carat is the weight of the diamonds (0.2-5.01). library(ggplot2) diamonds ## # A tibble: 53,940 x 10 ## carat cut color clarity depth table price x y z ## &lt;dbl&gt; &lt;ord&gt; &lt;ord&gt; &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0.23 Ideal E SI2 61.5 55 326 3.95 3.98 2.43 ## 2 0.21 Premium E SI1 59.8 61 326 3.89 3.84 2.31 ## 3 0.23 Good E VS1 56.9 65 327 4.05 4.07 2.31 ## 4 0.290 Premium I VS2 62.4 58 334 4.2 4.23 2.63 ## 5 0.31 Good J SI2 63.3 58 335 4.34 4.35 2.75 ## 6 0.24 Very Good J VVS2 62.8 57 336 3.94 3.96 2.48 ## 7 0.24 Very Good I VVS1 62.3 57 336 3.95 3.98 2.47 ## 8 0.26 Very Good H SI1 61.9 55 337 4.07 4.11 2.53 ## 9 0.22 Fair E VS2 65.1 61 337 3.87 3.78 2.49 ## 10 0.23 Very Good H VS1 59.4 61 338 4 4.05 2.39 ## # … with 53,930 more rows Let’s create three vectors for price, carat, and depth variables in the diamonds dataset. price &lt;- diamonds$price carat &lt;- diamonds$carat depth &lt;- diamonds$depth Now, we have a quite long vector. # carat and depth should have the same length b/c they came from the same dataset. length(price) ## [1] 53940 Some quiz problems need the round() function, which will return the integer part of the provided number. For quiz responses, please round your answers to the third decimal place. # round to the zero digit (which is integer) round(3.141592) ## [1] 3 # round to the first digit round(3.141592, digits = 3) ## [1] 3.142 6.0.2 Quiz problem 1 Do we have any missing value in price? (Yes, or No) sum(is.na(price)) ## [1] 0 sum(is.na(carat)) ## [1] 0 sum(is.na(depth)) ## [1] 0 6.0.3 Quiz problem 2 What is the sum of deviations of price from the mean? A deviation is computed by subtracting the mean of \\(X\\) from a given score. \\(d_i=X_i- mean(X)\\). In other words, calculate \\(d_i = \\sum_{i=1}^{n}[x_i-mean(x)]\\), where \\(x\\) is price. Report the integer part of the answer. Use round(x) which returns \\(x\\) without any decimals. round(sum(price - mean(price))) ## [1] 0 6.0.4 Quiz problem 3 Variance is defined as average squared devaiton. \\[Var(X)=\\frac{\\sum_{i=1}^n d_i^2}{n-1} =\\frac{\\sum_{i=1}^n (X-\\bar{X})^2}{n-1}\\]. Numerator is the sum of squared deviations computed in the previous problem. The denominator equals (\\(n-1\\)). What is the variance of the price variable? sum((price-mean(price))^2)/(length(price)-1) ## [1] 15915629 var(price) ## [1] 15915629 6.0.5 Quiz problem 4 You want to buy one of the diamonds in the diamonds dataset. However, you only(?) have $5,000. What is the largest size (in carat) of diamonds you can buy. max(carat[price&lt;=5000]) ## [1] 1.74 6.0.6 Quiz problem 5 Conglaturation !!! You won Mega Millions (happy). Now, you don’t have any budget limit. However, you have a strong belief that 7 is a lucky number. So you want to buy 7th, 77th, and 777th expensive diamonds. What is the total price of the three diamonds? sum(sort(price, decreasing = TRUE)[c(7, 77, 777)]) ## [1] 54183 6.0.7 Dataset2: bfi is a dataset in the psych package containing 25 personality self report items taken from the International Personality Item Pool. In the dataset, gender represents gender (Males = 1, Females = 2), education represent educational attainment (1 = HS, 2 = finished HS, 3 = some college, 4 = college graduate 5 = graduate degree), age represents age in years, and E3 is one of the five items that measures extraversion (“Know how to captivate people”). ## This is great- requires them to load and access data from a package. # You need to install and load the `psych` package to use the `bfi` dataset. library(psych) Let’s create three vectors for gender, education, and age variables in the diamonds dataset. gender &lt;- bfi$gender education &lt;- bfi$education age &lt;- bfi$age E3 &lt;- bfi$E3 6.0.8 Quiz problem 6 What is the type of each of these vectors (chracter, integer, double, factor)? typeof(gender) ## [1] &quot;integer&quot; typeof(education) ## [1] &quot;integer&quot; typeof(age) ## [1] &quot;integer&quot; typeof(E3) ## [1] &quot;integer&quot; 6.0.9 Quiz problem 7 What proportion of the sample is females? sum(gender == 2) ## [1] 1881 sum(gender == 2)/length(gender) ## [1] 0.6717857 table(gender) ## gender ## 1 2 ## 919 1881 prop.table(table(gender)) ## gender ## 1 2 ## 0.3282143 0.6717857 6.0.10 Quiz problem 8 What is the sample mean difference in E3 between males (gender = 1) younger than (&lt;) 26 and females (gender = 2) younger than (&lt;) 26? That is, mean of E3 for males younger than 26 - mean of E3 for females younger than 26. mean(E3[gender==1 &amp; age &lt; 26], na.rm = TRUE) - mean(E3[gender==2 &amp; age &lt; 26], na.rm = TRUE) ## [1] -0.07071837 6.0.11 Quiz problem 9 In the bfi dataset, how many males with age 16 and highschool degree are there? sum((gender == 1) &amp; (education == 1) &amp; (age == 16), na.rm = TRUE) ## [1] 6 6.0.12 Quiz problem 10 Using the bfi data set, what is the count of 42 year old females? sum(age == 42 &amp; gender == 2) ## [1] 21 "]
]
